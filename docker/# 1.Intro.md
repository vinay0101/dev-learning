# ğŸ§  Docker: The Right Mental Model

Before learning commands, understand the core philosophy: **Docker is a process manager + filesystem manager.**

Docker's primary jobs:
1.  Starts **Linux processes**.
2.  Gives them **isolated filesystems**.
3.  Connects them to **networks**.
4.  Limits their **CPU/RAM** usage.

---

## ğŸ“¦ Images vs. Containers

| Concept | What it really is | Analogy |
| :--- | :--- | :--- |
| **Image** | A read-only filesystem snapshot + startup command | The Blueprint |
| **Container** | A running Linux process using that filesystem | The Building |



---

## â–¶ï¸ What happens during `docker run node`?

When you execute the command, Docker performs these steps:
1.  **Downloads** the `node` image (if not already local).
2.  **Creates** a new, isolated filesystem.
3.  **Starts** a Linux process: `node`.

**The "Invisible Exit" Problem:**
* By default, no terminal is attached. Node has no input.
* The Node process finishes immediately.
* Because the process ends, the container stops. **The container didn't fail; it simply finished its job.**

### ğŸ§ª Interactive Mode
`docker run -it node`

* **-i (interactive):** Connects `STDIN` (your keyboard).
* **-t (tty):** Attaches a terminal.
* **Result:** The Node REPL stays alive until you type `.exit`.

---

## ğŸ” Monitoring Containers

| Command | Shows |
| :--- | :--- |
| `docker ps` | Only **running** containers |
| `docker ps -a` | **All** containers (Running + Stopped + Exited) |

> **Note:** Containers are like old terminal sessions. Docker keeps the history (and the disk space they occupy) unless you explicitly delete them.

---

## ğŸ›‘ Exit Codes (Production Critical)

These codes are how systems like **Kubernetes** determine if your service is healthy.

| Code | Meaning | Context |
| :--- | :--- | :--- |
| **0** | Success | Program finished normally. |
| **1** | Crash | Application error/exception. |
| **137** | OOM Killed | Out of Memory (OS killed the process). |
| **143** | SIGTERM | Graceful stop initiated by Docker/K8s. |
| **130** | SIGINT | Interrupted by `Ctrl+C`. |

---

## ğŸŒ Port Mapping
`docker run -p 3000:80 myapp`

Think of this as a tunnel:
**Laptop Port 3000** â®• **Docker Proxy** â®• **Container Port 80**

1.  Browser hits `localhost:3000`.
2.  Docker forwards traffic to the container's internal port `80`.
3.  The Node server inside handles the request.

---

## ğŸ§± Custom Images (The Dockerfile)

```dockerfile
FROM node           # Base OS + runtime
WORKDIR /app        # 'cd' into folder
COPY . /app         # Move files into the image
RUN npm install     # Execute once during build
EXPOSE 80           # Documentation (internal port)
CMD ["node", "s.js"] # Command to run on START

```

### ğŸ§… Image Layers & Caching

Docker builds images in layers. Order matters for speed.

**âŒ Bad (Slow):**

```dockerfile
COPY . .
RUN npm install

```

*Any* file change breaks the cache for the entire `npm install`.

**âœ… Good (Fast):**

```dockerfile
COPY package.json .
RUN npm install
COPY . .

```

If your code changes but `package.json` doesn't, Docker skips `npm install` and uses the cached layer.

---

## ğŸ–¥ Containers vs. Virtual Machines

| Feature | Docker (Containers) | Virtual Machines (VMs) |
| --- | --- | --- |
| **OS** | Shares Host OS Kernel | Has its own full Guest OS |
| **Speed** | Starts in milliseconds | Takes minutes to boot |
| **Size** | Extremely lightweight (MBs) | Heavy (GBs) |
| **Nature** | Process Isolation | Hardware Virtualization |

---

## ğŸ§  Docker Architecture

The flow of control:
**You** â®• **Docker CLI** â®• **Docker Daemon** â®• **Linux Kernel**

**The Golden Rule:** Docker doesnâ€™t run containersâ€”**Linux** does. Docker is just the user-friendly interface that tells Linux how to isolate the process.
